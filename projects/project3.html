<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Takuzu Solver</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="../style.css"> 
    <link rel="icon" type="image/png" href="../attachments/takuzu.ico">
    
</head>
<body>
    <header class="header">
        <a href="../index.html" class="home">üè†</a>
        <a href="../about.html" class="logo">Triplaqs</a>
        <a href="../about.html" class="logo-about"><em><i class="fa-solid fa-user-circle" aria-hidden="true"></i> About me  </em></a>
    </header>

    <main class="project-container">
        
        <h1 class="project-title">Takuzu Solver</h1>
        <p class="project-intro">Takuzu solver for 2n√ó2n grid and along with an exhaustive algorithm to prove the amount of case that has to be displayed to get the unicity of the solution.</p>
        <a href="https://github.com/Triplaqs/Takuzu-Solver-TIPE-" class="custom-link"><i class="fa-brands fa-github"></i> <em> Github Link</em> <i class="fa fa-external-link" aria-hidden="true"></i></a>

        <section class="visual-block">
            <h3>Context</h3>
            <p>For my TIPE in Preparatory Class for Grandes √âcoles (2022 - 2024); I had the subject "<em>Sports and games</em>".
                I was already interested in Correction Codes and I often played Takuzus (Sudokus with only 0 and 1). 
                So I naturally thought that with some constraints in data structure, we might actually be able to use the solving of Takuzu as a Correction Code.
                My searched then split into two parts :
                <br>First, create a Takuzu Solver and be able to tell how many data loss I could handle without losing the original data (<em>i.e.</em> the number of cases that we can hide on a solved Takuzu grid while keeping a unique solution).
                <br>Then, determine if we can structure a data sequence of bits as a Takuzu grid.   
                <br><br> A Takuzu grid is a grid composed of 0 and 1 with the following constraints :
                <ul>
                    <li> No more than two identical bits can be adjacent in a row or in a column. </li>
                    <li> Each row and each column must contain an equal number of 0 and 1. </li>
                    <li> No two rows and no two columns can be identical. </li>
                </ul>              
            </p>

        <section class="visual-block">
            <h3>Development</h3>
            <p>The research part concerning the restructuration of a bit sequence I proceeded in 3 steps :
            <ul>
                <li> First count the number of bit composing the data set and enumerate the different decompositions in Takuzus grid possible (a Takuzu grid is an even number squared bits). </li>
                <li> Second, we try to decompose our actual bit sequence in the different Takuzus grid list calculated precedently. </li>
                <li> Third, we check if the decompositions are valid Takuzu grids (respect the 3 constraints listed above). </li>
            </ul>   
            Then if one of them is valid, we can consider that the data sequence can be structured as a Takuzu grid.
            <br>Here's two example of the algorithm with a 2x2 pixels image which is not transformable into Takuzu grids and a one-pixel image which is transformable into Takuzu grids :
            </p>
            <div class="white-frame-double">
                 <img src="../attachments/binairo.png" alt="First test of Takuzing images" class="img-small-bigger">
                 <img src="../attachments/binairo2.png" alt="Second test of Takuzing images">
            </div>
            <p>The resolution and proof part requires less thinking but takes more time developing. :
            <ul>
                <li> I had to implement each condition verification for rows and columns. </li>
                <li> Then I could make a backtracking algorithm to solve the Takuzu grid. </li>
                <li> In the end, I made an exaustive algorithm that calculate every Takuzu grids of a given dimension, and searched if they were solvable with a given amount of cases deleted.</li>
            </ul>   
            We can determine that from 4 cases deleted in any Takuzu grid, we might lose the unicity of the solution. Determining the exact amount of data loss the "Correction Code" can handle.
            <br> Here are some exemples of resolution and proof results (sadly from bigger than 4x4 Takuzu grids, the exhaustive algorithm crashes due to lack of memory): 
            </p>
            <div class="white-frame-double">
                 <img src="../attachments/resolution.png" alt="Resolution of a Takuzu grid">
                 <img src="../attachments/cns.png" alt="Calculation of the amount of cases" class="img-small">
            </div>
        </section>

        <section class="visual-block">
            <h3>Conclusion</h3>
            <p>To conclude, the Takuzu form Correction Code might be very efficient for data transmission with a small amount of data loss. 
                However, the structuration of a data sequence into a Takuzu grid seems very limited. Furthermore in real life, we don't actually know where are the data losses, making this method unusable.
            </p>

    <!--PASSAGE AU TEST-->

    <h1>Takuzu Solver (WASM)</h1>

    <div class="controls">
        <label>Taille : 
            <select id="size-select" onchange="generateGrid()">
                <option value="4">4x4</option>
                <option value="6" selected>6x6</option>
                <option value="8">8x8</option>
                <option value="10">10x10</option>
            </select>
        </label>
        <button onclick="solveGrid()">R√âSOUDRE</button>
        <button onclick="generateGrid()">Reset</button>
    </div>

    <div id="grid-container"></div>
    <div id="status"></div>

    <script src="../scripts/takuzu.js"></script>

    <script>
        let currentSize = 6;

        // G√©n√®re les inputs HTML
        function generateGrid() {
            currentSize = parseInt(document.getElementById('size-select').value);
            const container = document.getElementById('grid-container');
            
            // Configuration CSS de la grille dynamique
            container.style.gridTemplateColumns = `repeat(${currentSize}, 50px)`;
            container.innerHTML = '';

            for (let i = 0; i < currentSize * currentSize; i++) {
                const input = document.createElement('input');
                input.type = 'text';
                input.className = 'cell';
                input.maxLength = 1;
                input.dataset.index = i;
                
                // Validation simple : seulement 0 ou 1
                input.oninput = function() {
                    this.value = this.value.replace(/[^01]/g, '');
                };
                container.appendChild(input);
            }
            document.getElementById('status').innerText = "";
        }

        // Fonction appel√©e par le bouton "R√©soudre"
        function solveGrid() {
            if (!Module._solve_wrapper) {
                alert("Le module WASM n'est pas encore charg√©. Attendez un instant.");
                return;
            }

            const cells = document.querySelectorAll('.cell');
            const n = currentSize;
            
            // 1. Pr√©parer les donn√©es pour le C
            // On utilise un tableau typ√© JS (Int32Array correspond au 'int' du C)
            const inputData = new Int32Array(n * n);
            
            cells.forEach((cell, index) => {
                const val = cell.value;
                // Si vide, on met -1, sinon la valeur (0 ou 1)
                inputData[index] = val === '' ? -1 : parseInt(val);
            });

            // 2. Allouer de la m√©moire dans le TAS (Heap) du module WASM
            // 4 octets par entier (32-bit integer)
            const numBytes = n * n * 4;
            const dataPtr = Module._malloc(numBytes);

            // 3. Copier les donn√©es JS vers la m√©moire C
            // HEAP32 est la vue de la m√©moire en entiers 32 bits
            // dataPtr >> 2 divise l'adresse m√©moire par 4 pour obtenir l'index du tableau
            Module.HEAP32.set(inputData, dataPtr >> 2);

            // 4. Appeler la fonction C
            console.log("Appel du solveur C...");
            const success = Module._solve_wrapper(dataPtr, n);

            if (success) {
                // 5. Lire le r√©sultat depuis la m√©moire C
                // On cr√©e une vue sur la zone m√©moire modifi√©e par le C
                const resultData = Module.HEAP32.subarray(dataPtr >> 2, (dataPtr >> 2) + n * n);

                // 6. Mettre √† jour l'affichage
                cells.forEach((cell, index) => {
                    if (cell.value === '') { // Si c'√©tait une case vide
                        cell.value = resultData[index];
                        cell.classList.add('solved'); // Petit effet visuel
                    }
                });
                document.getElementById('status').innerText = "R√©solu avec succ√®s !";
            } else {
                document.getElementById('status').innerText = "Impossible de r√©soudre (Invalide ou trop complexe).";
            }

            // 7. Lib√©rer la m√©moire (tr√®s important !)
            Module._free(dataPtr);
        }

        // Initialisation au chargement
        Module.onRuntimeInitialized = function() {
            generateGrid();
            console.log("WASM Charg√© et pr√™t");
        };
        </script>
    </main>
</body>
</html>